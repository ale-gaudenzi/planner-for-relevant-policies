\hypertarget{structDeadendAwareSuccessorGenerator}{}\doxysection{Deadend\+Aware\+Successor\+Generator Struct Reference}
\label{structDeadendAwareSuccessorGenerator}\index{DeadendAwareSuccessorGenerator@{DeadendAwareSuccessorGenerator}}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{structDeadendAwareSuccessorGenerator_ab11336ee528705ffd274437e30c281c9}{generate\+\_\+applicable\+\_\+ops}} (const \mbox{\hyperlink{classStateInterface}{State\+Interface}} \&curr, vector$<$ const \mbox{\hyperlink{classOperator}{Operator}} $\ast$ $>$ \&ops)
\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{structDeadendAwareSuccessorGenerator_ab11336ee528705ffd274437e30c281c9}\label{structDeadendAwareSuccessorGenerator_ab11336ee528705ffd274437e30c281c9}} 
\index{DeadendAwareSuccessorGenerator@{DeadendAwareSuccessorGenerator}!generate\_applicable\_ops@{generate\_applicable\_ops}}
\index{generate\_applicable\_ops@{generate\_applicable\_ops}!DeadendAwareSuccessorGenerator@{DeadendAwareSuccessorGenerator}}
\doxysubsubsection{\texorpdfstring{generate\_applicable\_ops()}{generate\_applicable\_ops()}}
{\footnotesize\ttfamily void Deadend\+Aware\+Successor\+Generator\+::generate\+\_\+applicable\+\_\+ops (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classStateInterface}{State\+Interface}} \&}]{curr,  }\item[{vector$<$ const \mbox{\hyperlink{classOperator}{Operator}} $\ast$ $>$ \&}]{ops }\end{DoxyParamCaption})}

For resilient planner\+: we retrieve the forbidden state-\/action pairs relative to the current (k,V) key of fault model and add them to the deadends of the current search

For resilient planner\+: we don\textquotesingle{}t push back the operator if it is forbidden (= found in current node V)
\begin{DoxyCode}{0}
\DoxyCodeLine{161 \{}
\DoxyCodeLine{162     \textcolor{keywordtype}{bool} verbose = \textcolor{keyword}{false};}
\DoxyCodeLine{163     \textcolor{keywordflow}{if} (g\_detect\_deadends \&\& g\_deadend\_policy)}
\DoxyCodeLine{164     \{}
\DoxyCodeLine{165         \mbox{\hyperlink{classPartialState}{PartialState}} curr = \mbox{\hyperlink{classPartialState}{PartialState}}(\_curr);}
\DoxyCodeLine{166 }
\DoxyCodeLine{167         \textcolor{keywordtype}{bool} debug = \textcolor{keyword}{false};}
\DoxyCodeLine{168 }
\DoxyCodeLine{169         \textcolor{keywordflow}{if} (debug)}
\DoxyCodeLine{170             cout << \textcolor{stringliteral}{"\(\backslash\)nRunning the deadend aware successor generator..."} << endl;}
\DoxyCodeLine{171 }
\DoxyCodeLine{172         vector<PolicyItem *> reg\_items;}
\DoxyCodeLine{173         vector<const Operator *> orig\_ops;}
\DoxyCodeLine{174         map<int, PolicyItem *> fsap\_map;}
\DoxyCodeLine{175 }
\DoxyCodeLine{176         g\_successor\_generator\_orig-\/>generate\_applicable\_ops(\_curr, orig\_ops, \textcolor{keyword}{true});}
\DoxyCodeLine{177         g\_deadend\_policy-\/>generate\_applicable\_items(curr, reg\_items, \textcolor{keyword}{false}, \textcolor{keyword}{false});}
\DoxyCodeLine{178 }
\DoxyCodeLine{179         }
\DoxyCodeLine{184         \textcolor{keywordflow}{if} (g\_use\_resilient\_planner)}
\DoxyCodeLine{185         \{}
\DoxyCodeLine{186             \textcolor{keywordflow}{if} (g\_fault\_model.find(std::make\_pair(g\_current\_faults, g\_current\_forbidden\_ops)) != g\_fault\_model.end())}
\DoxyCodeLine{187             \{}
\DoxyCodeLine{188                 \mbox{\hyperlink{classPolicy}{Policy}} *current\_forbidden = g\_fault\_model[std::make\_pair(g\_current\_faults, g\_current\_forbidden\_ops)];}
\DoxyCodeLine{189                 current\_forbidden-\/>generate\_applicable\_items(curr, reg\_items, \textcolor{keyword}{false}, \textcolor{keyword}{false});}
\DoxyCodeLine{190             \}}
\DoxyCodeLine{191         \}}
\DoxyCodeLine{192 }
\DoxyCodeLine{193         set<int> forbidden;}
\DoxyCodeLine{194         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < reg\_items.size(); i++)}
\DoxyCodeLine{195         \{}
\DoxyCodeLine{196             \textcolor{keywordtype}{int} index = ((\mbox{\hyperlink{structNondetDeadend}{NondetDeadend}} *)(reg\_items[i]))-\/>op\_index;}
\DoxyCodeLine{197 }
\DoxyCodeLine{198             forbidden.insert(index);}
\DoxyCodeLine{199 }
\DoxyCodeLine{200             \textcolor{keywordflow}{if} ((fsap\_map.find(index) == fsap\_map.end()) ||}
\DoxyCodeLine{201                 (reg\_items[i]-\/>state-\/>size() < fsap\_map[index]-\/>state-\/>size()))}
\DoxyCodeLine{202                 fsap\_map[index] = reg\_items[i];}
\DoxyCodeLine{203         \}}
\DoxyCodeLine{204 }
\DoxyCodeLine{205         vector<int> ruled\_out;}
\DoxyCodeLine{206         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < orig\_ops.size(); i++)}
\DoxyCodeLine{207         \{}
\DoxyCodeLine{208             \textcolor{keywordflow}{if} (0 == forbidden.count(orig\_ops[i]-\/>nondet\_index))}
\DoxyCodeLine{209             \{}
\DoxyCodeLine{210                 \textcolor{keywordflow}{if} (debug)}
\DoxyCodeLine{211                     cout << \textcolor{stringliteral}{"Allowing operator "} << orig\_ops[i]-\/>get\_name() << endl;}
\DoxyCodeLine{212 }
\DoxyCodeLine{216                 \textcolor{keywordflow}{if} (g\_use\_resilient\_planner)}
\DoxyCodeLine{217                 \{}
\DoxyCodeLine{218                     \textcolor{keywordflow}{if} (g\_current\_forbidden\_ops.find(*orig\_ops[i]) == g\_current\_forbidden\_ops.end()) \{}
\DoxyCodeLine{219                         \textcolor{keywordflow}{if}(verbose)\{}
\DoxyCodeLine{220                             cout << \textcolor{stringliteral}{"Allowing operator "} << orig\_ops[i]-\/>get\_name() << endl;}
\DoxyCodeLine{221                         \}}
\DoxyCodeLine{222                         ops.push\_back(orig\_ops[i]);}
\DoxyCodeLine{223                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{224                         \textcolor{keywordflow}{if}(verbose)\{}
\DoxyCodeLine{225                             cout << \textcolor{stringliteral}{"Forbidding operator "} << orig\_ops[i]-\/>get\_name() << endl;}
\DoxyCodeLine{226                         \}}
\DoxyCodeLine{227                     \}}
\DoxyCodeLine{228                 \}}
\DoxyCodeLine{229                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{230                 \{}
\DoxyCodeLine{231                     ops.push\_back(orig\_ops[i]);}
\DoxyCodeLine{232                 \}}
\DoxyCodeLine{233             \}}
\DoxyCodeLine{234             \textcolor{keywordflow}{else}}
\DoxyCodeLine{235             \{}
\DoxyCodeLine{236                 \textcolor{keywordflow}{if} (g\_combine\_deadends)}
\DoxyCodeLine{237                     ruled\_out.push\_back(orig\_ops[i]-\/>nondet\_index);}
\DoxyCodeLine{238 }
\DoxyCodeLine{239                 \textcolor{comment}{/* HAZ: Since we are using the ff heuristic with preferred operators,}}
\DoxyCodeLine{240 \textcolor{comment}{                 *      we don't want the preferred operators to sneak into the applicable}}
\DoxyCodeLine{241 \textcolor{comment}{                 *      list of actions. As such, we "mark" the operator which prevents}}
\DoxyCodeLine{242 \textcolor{comment}{                 *      the operator from being added. See LazySearch::get\_successor\_operators}}
\DoxyCodeLine{243 \textcolor{comment}{                 *      for where this occurrs.}}
\DoxyCodeLine{244 \textcolor{comment}{                 */}}
\DoxyCodeLine{245                 orig\_ops[i]-\/>mark();}
\DoxyCodeLine{246 }
\DoxyCodeLine{247                 \textcolor{keywordflow}{if} (debug)}
\DoxyCodeLine{248                     cout << \textcolor{stringliteral}{"Forbidding operator "} << orig\_ops[i]-\/>get\_name() << endl;}
\DoxyCodeLine{249             \}}
\DoxyCodeLine{250         \}}
\DoxyCodeLine{251 }
\DoxyCodeLine{252         \textcolor{comment}{// Add this state as a deadend if we have ruled out everything}}
\DoxyCodeLine{253         \textcolor{keywordflow}{if} (!g\_limit\_states \&\& g\_record\_online\_deadends \&\&}
\DoxyCodeLine{254             g\_combine\_deadends \&\& (orig\_ops.size() > 0) \&\& ops.empty())}
\DoxyCodeLine{255         \{}
\DoxyCodeLine{256 }
\DoxyCodeLine{257             \mbox{\hyperlink{classPartialState}{PartialState}} *newDE = \textcolor{keyword}{new} \mbox{\hyperlink{classPartialState}{PartialState}}();}
\DoxyCodeLine{258             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < ruled\_out.size(); i++)}
\DoxyCodeLine{259             \{}
\DoxyCodeLine{260                 newDE-\/>combine\_with(*(((\mbox{\hyperlink{structNondetDeadend}{NondetDeadend}} *)(fsap\_map[ruled\_out[i]]))-\/>state));}
\DoxyCodeLine{261             \}}
\DoxyCodeLine{262 }
\DoxyCodeLine{263             \textcolor{keywordflow}{if} (debug)}
\DoxyCodeLine{264             \{}
\DoxyCodeLine{265                 cout << \textcolor{stringliteral}{"<< (\#"} << g\_debug\_count++ << \textcolor{stringliteral}{") Found a new deadend state of size "} << newDE-\/>size() << \textcolor{stringliteral}{" >>"} << endl;}
\DoxyCodeLine{266                 newDE-\/>dump\_pddl();}
\DoxyCodeLine{267             \}}
\DoxyCodeLine{268 }
\DoxyCodeLine{269             g\_combined\_count++;}
\DoxyCodeLine{270 }
\DoxyCodeLine{271             vector<DeadendTuple *> failed\_states;}
\DoxyCodeLine{272             failed\_states.push\_back(\textcolor{keyword}{new} \mbox{\hyperlink{structDeadendTuple}{DeadendTuple}}(newDE, NULL, NULL));}
\DoxyCodeLine{273             g\_updated\_deadends = \textcolor{keyword}{true};}
\DoxyCodeLine{274             update\_deadends(failed\_states);}
\DoxyCodeLine{275         \}}
\DoxyCodeLine{276     \}}
\DoxyCodeLine{277     \textcolor{keywordflow}{else}}
\DoxyCodeLine{278     \{}
\DoxyCodeLine{279         g\_successor\_generator\_orig-\/>generate\_applicable\_ops(\_curr, ops, \textcolor{keyword}{true});}
\DoxyCodeLine{280     \}}
\DoxyCodeLine{281 }
\DoxyCodeLine{282     \textcolor{keywordflow}{return};}
\DoxyCodeLine{283 \}}

\end{DoxyCode}


The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/search/policy-\/repair/deadend.\+h\item 
src/search/policy-\/repair/deadend.\+cc\end{DoxyCompactItemize}
